pid_t - целое число со знаком, который способен представить id процесса.

pipe() - takes array of 2 ints (int end[2]) and links them together
Also, pipe() assigns an fd to each end.
end[1] will write to its own fd, and end[0] will be able to see and read end[1]'s fd and write to its own.
		pipe(end)

fork() - splits the process in two sub-processes: returns 0 for child, non-zero for parent,
-1 in case of  error
fork() splits the process in two parallel processesm that happen at the same time.

One end writes, while the other waits.

For the child process - the INFILE is input and end[1] is output (write to end[1] the output of cmd[1]
						so the parent can read it)
In the parent process - end[0] is the input (end[0] has already read from end[1] the output of cmd[1])
						and OUTFILE will be output (we want to write it to the output of cmd2)

dup2() can swap our fds to stdin/stdout
man: int dup2(int fd1, int fd2) will close fd2 and duplicate the value of fd2 to fd1 (redirect fd1 to fd2)

execve(const char *path, const char **argv, const char **envp) - execute the file

1) 2 pid_t variables
2) 2 fds
3) fork() applied to child1 (pid_t variable)
4) if child1 == 0, open argv[1] w/ RDONLY, (f) execute argv[2], (envp?)
5) fork() applies to child2 (pid_t variable)
6) 